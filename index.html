<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Agentarium Graph - Three.js</title>
  <style>
    html,body { height:100%; margin:0; background:#061018; }
    canvas { display:block; }
    .tooltip { position: absolute; padding:8px 10px; background:rgba(0,0,0,0.7); color:#fff; border-radius:6px; pointer-events:none; font-family: Arial; font-size:13px; transform: translate(-50%,-120%); }
  </style>
</head>
<body>
<div id="container"></div>
<div id="tooltip" class="tooltip" style="display:none;"></div>
<script type="module">
import * as THREE from 'https://unpkg.com/three@0.156.0/build/three.module.js';
import { OrbitControls } from 'https://unpkg.com/three@0.156.0/examples/jsm/controls/OrbitControls.js';
import { UnrealBloomPass } from 'https://unpkg.com/three@0.156.0/examples/jsm/postprocessing/UnrealBloomPass.js';
import { EffectComposer } from 'https://unpkg.com/three@0.156.0/examples/jsm/postprocessing/EffectComposer.js';
import { RenderPass } from 'https://unpkg.com/three@0.156.0/examples/jsm/postprocessing/RenderPass.js';

const container = document.getElementById('container');
const tooltip = document.getElementById('tooltip');

const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x061018, 0.0025);

const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.1, 2000);
camera.position.set(0, 0, 120);

const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
container.appendChild(renderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.07;

// lights
scene.add(new THREE.AmbientLight(0x66a3ff, 0.08));
const pLight = new THREE.PointLight(0x66e0ff, 0.6, 300);
pLight.position.set(50, 50, 50);
scene.add(pLight);

// background particle field
const particleGeom = new THREE.BufferGeometry();
const P = 400;
const positions = new Float32Array(P * 3);
for (let i=0; i<P; i++){
  positions[3*i] = (Math.random()-0.5)*300;
  positions[3*i+1] = (Math.random()-0.5)*300;
  positions[3*i+2] = (Math.random()-0.5)*300;
}
particleGeom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
const particleMat = new THREE.PointsMaterial({ size: 0.9, color: 0x0fd6ff, opacity: 0.08, transparent: true });
const particles = new THREE.Points(particleGeom, particleMat);
scene.add(particles);

// create instanced nodes
const NODE_COUNT = 60;
const sphereGeo = new THREE.SphereGeometry(1.6, 8, 8);
const instMat = new THREE.MeshBasicMaterial({ color: 0x19e0ff });
const inst = new THREE.InstancedMesh(sphereGeo, instMat, NODE_COUNT);
scene.add(inst);

const dummy = new THREE.Object3D();
const nodeData = [];
for (let i=0;i<NODE_COUNT;i++){
  const x = (Math.random()-0.5)*80;
  const y = (Math.random()-0.5)*50;
  const z = (Math.random()-0.5)*40;
  dummy.position.set(x,y,z);
  dummy.scale.setScalar(1 + Math.random()*1.5);
  dummy.updateMatrix();
  inst.setMatrixAt(i, dummy.matrix);
  nodeData.push({id:`n${i}`, x,y,z, size:1+Math.random(), label:`Agent ${i}`, activity: Math.random()});
}
inst.instanceMatrix.needsUpdate = true;

// links (LineSegments)
const linkGeom = new THREE.BufferGeometry();
const maxLinks = NODE_COUNT * 3;
const linkPos = new Float32Array(maxLinks * 2 * 3);
let linkCount = 0;
for (let i=0;i<NODE_COUNT;i++){
  const a = i;
  for (let k=0;k<2;k++){
    const b = Math.floor(Math.random()*NODE_COUNT);
    if (a===b) continue;
    linkPos.set([nodeData[a].x, nodeData[a].y, nodeData[a].z], (linkCount*2)*3);
    linkPos.set([nodeData[b].x, nodeData[b].y, nodeData[b].z], (linkCount*2+1)*3);
    linkCount++;
  }
}
linkGeom.setAttribute('position', new THREE.BufferAttribute(linkPos, 3));
const linkMat = new THREE.LineBasicMaterial({ color:0x0bb7ff, transparent:true, opacity:0.25 });
const links = new THREE.LineSegments(linkGeom, linkMat);
scene.add(links);

// postprocessing bloom
const composer = new EffectComposer(renderer);
composer.addPass(new RenderPass(scene, camera));
const bloom = new UnrealBloomPass(new THREE.Vector2(innerWidth, innerHeight), 0.7, 0.4, 0.2);
bloom.threshold = 0.1; bloom.strength = 0.6; bloom.radius = 0.8;
composer.addPass(bloom);

// raycasting for hover
const ray = new THREE.Raycaster();
const mouse = new THREE.Vector2();
let hoveredIndex = -1;
window.addEventListener('mousemove', (ev)=>{
  mouse.x = (ev.clientX / innerWidth) * 2 - 1;
  mouse.y = -(ev.clientY / innerHeight) * 2 + 1;
});

// animate
const clock = new THREE.Clock();
function animate(){
  requestAnimationFrame(animate);
  const t = clock.getElapsedTime();
  // subtle particle movement
  particleGeom.attributes.position.array.forEach((v,i)=>{
    particleGeom.attributes.position.array[i] += Math.sin(t*0.02 + i)*0.0002;
  });
  particleGeom.attributes.position.needsUpdate = true;

  // animate nodes (pulse)
  for (let i=0;i<NODE_COUNT;i++){
    inst.getMatrixAt(i, dummy.matrix);
    dummy.position.set(nodeData[i].x, nodeData[i].y, nodeData[i].z);
    const scale = 1 + 0.3*Math.sin(t*2 + i);
    dummy.scale.setScalar(scale);
    dummy.updateMatrix();
    inst.setMatrixAt(i, dummy.matrix);
  }
  inst.instanceMatrix.needsUpdate = true;

  controls.update();

  // hover detection
  ray.setFromCamera(mouse, camera);
  const intersects = ray.intersectObject(inst);
  if (intersects.length){
    const instanceId = intersects[0].instanceId;
    if (instanceId !== hoveredIndex){
      hoveredIndex = instanceId;
      const d = nodeData[instanceId];
      tooltip.style.display = 'block';
      tooltip.style.left = (event.clientX)+'px';
      tooltip.style.top = (event.clientY)+'px';
      tooltip.innerHTML = `<strong>${d.label}</strong><br>Activity: ${(d.activity*100).toFixed(0)}%`;
    }
  } else {
    hoveredIndex = -1;
    tooltip.style.display = 'none';
  }

  composer.render();
}
animate();

// handle resize
window.addEventListener('resize', ()=>{
  const w = innerWidth, h = innerHeight;
  renderer.setSize(w,h); composer.setSize(w,h);
  camera.aspect = w/h; camera.updateProjectionMatrix();
});
</script>
</body>
</html>
