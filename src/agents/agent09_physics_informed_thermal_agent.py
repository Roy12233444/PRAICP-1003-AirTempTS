# AUTOGENERATED BY AetherOrchestrator at 2025-09-21 18:05:33
# Family: physics
# NOTE: review this file manually before production use

# Auto-generated: PhysicsInformedThermalAgent - PLEASE REVIEW
from typing import Optional, Dict, Any
import numpy as np
import pandas as pd
from sklearn.ensemble import GradientBoostingRegressor
from agents.agent_base import BaseAgent
from scipy.signal import savgol_filter

class PhysicsInformedThermalAgent(BaseAgent):
    """
    Practical 'physics-informed' wrapper:
    - Fit a GradientBoostingRegressor on features
    - During predict apply a smoothing penalty using Savitzky-Golay filter
      to enforce smoothness (proxy for physics).
    NOTE: this is a pragmatic approach for the capstone; replace with PINN if desired.
    """
    def __init__(self, config: Optional[Dict[str, Any]] = None):
        super().__init__(config)
        self.model = None
        self.smooth_window = int(self.config.get("smooth_window", 5))
        self.polyorder = int(self.config.get("polyorder", 2))

    def fit(self, df: pd.DataFrame, target_col: str = "mean_temp", feature_cols: Optional[list] = None):
        if feature_cols is None:
            # use simple lags if nothing provided
            arr = df[target_col].astype(float)
            X = pd.DataFrame({f"lag_{i}": arr.shift(i) for i in range(1,4)}).fillna(method="bfill")
        else:
            X = df[feature_cols].fillna(0.0)
        y = df[target_col].astype(float).fillna(method='ffill').fillna(0.0)
        self.model = GradientBoostingRegressor(n_estimators=200, learning_rate=0.05, random_state=42)
        self.model.fit(X, y)
        self.feature_cols = X.columns.tolist()
        return self

    def predict(self, df: pd.DataFrame):
        X = df[self.feature_cols].fillna(0.0)
        raw = self.model.predict(X)
        # apply Savitzky-Golay smoothing to enforce smoothness (physics proxy)
        win = self.smooth_window
        if len(raw) < win:
            smoothed = raw
        else:
            # ensure window is odd and <= len
            if win % 2 == 0:
                win = win - 1
            win = max(3, min(win, len(raw) if len(raw)%2==1 else len(raw)-1))
            smoothed = savgol_filter(raw, win, self.polyorder)
        # return in uniform dict format
        return {"mu": float(smoothed[-1]) if len(smoothed)>0 else float(np.nan),
                "series": smoothed, "var": float(np.var(raw - smoothed) + 1e-6)}
