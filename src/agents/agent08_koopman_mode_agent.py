# AUTOGENERATED BY AetherOrchestrator at 2025-09-21 18:15:30
# Family: koopman
# NOTE: review this file manually before production use

# Auto-generated: KoopmanModeAgent (basic EDMD) - PLEASE REVIEW
from typing import Optional, Dict, Any
import numpy as np
import pandas as pd
from agents.agent_base import BaseAgent

class KoopmanModeAgent(BaseAgent):
    """
    Basic EDMD implementation using polynomial + trig observables.
    Fit: construct G0,G1 from lag vectors and solve K = G1 @ pinv(G0)
    Transform: project state observables onto Koopman eigenvectors (modes).
    Note: this is a starter implementation â€” review and refine.
    """

    def __init__(self, config: Optional[Dict[str, Any]] = None):
        super().__init__(config)
        self.lag = int(self.config.get("lag", 3))
        self.obs_degree = int(self.config.get("poly_degree", 2))
        self.K = None
        self.modes = None

    def _observables(self, x_vec):
        # build polynomial observables [1, x1, x1^2, x2, x2^2, sin(x1), cos(x1), ...]
        feats = [1.0]
        for xi in x_vec:
            for p in range(1, self.obs_degree + 1):
                feats.append(xi ** p)
            feats.append(np.sin(xi))
            feats.append(np.cos(xi))
        return np.asarray(feats, dtype=float)

    def fit(self, df, target_col="mean_temp"):
        # build lagged state matrix (rows: time, cols: lag features)
        arr = df[target_col].astype(float).values
        N = len(arr) - self.lag
        if N <= 0:
            raise ValueError("Not enough data for Koopman fit with lag={}".format(self.lag))
        G0_list, G1_list = [], []
        for t in range(N):
            x_t = arr[t : t + self.lag]
            x_tp1 = arr[t + 1 : t + 1 + self.lag]
            G0_list.append(self._observables(x_t))
            G1_list.append(self._observables(x_tp1))
        G0 = np.vstack(G0_list).T  # shape (d, N)
        G1 = np.vstack(G1_list).T
        # EDMD: K = G1 @ pinv(G0)
        G0_pinv = np.linalg.pinv(G0)
        K = G1 @ G0_pinv
        self.K = K
        # eigen-decomposition for modes
        try:
            vals, vecs = np.linalg.eig(K)
            self.modes = (vals, vecs)
        except Exception:
            self.modes = None
        return self

    def transform(self, df, target_col="mean_temp"):
        # project last lag into observables and (optionally) return mode amplitudes
        arr = df[target_col].astype(float).values
        if len(arr) < self.lag:
            raise ValueError("Not enough points for transform")
        x = arr[-self.lag :]
        g = self._observables(x)
        if self.modes is not None and self.modes[1] is not None:
            # coordinates in mode basis
            vecs = self.modes[1]
            coords = np.linalg.lstsq(vecs, g, rcond=None)[0]
            out = df.copy().reset_index(drop=True)
            for i, val in enumerate(np.real(coords)):
                out[f"koopman_mode_{i}"] = float(val)
            return out
        else:
            out = df.copy().reset_index(drop=True)
            out["koopman_feat0"] = float(g[0])
            return out
